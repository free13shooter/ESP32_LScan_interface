#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_system.h"
#include "esp_spi_flash.h"
#include "esp_task_wdt.h"
#include "spi_drv/spi_drv.hpp"
#include <AP_server.hpp>
#include <esp_random.h>
//ESP32-WROOM-32U MODE DIO 4MB
//____________________________________________________________________________________________________________//
//#define TESTING
//#define TESTSPI
//#define TESTSPI_RST

#ifdef TESTSPI
  void SPI_test();
#endif

#define GPIOSW          0     // button (0), dev board v.4
#define _getButton      digitalRead(GPIOSW) //active=LOW

using namespace std;

// GPIOSW interrupt
static void IRAM_ATTR gpio_SW_handler(void* arg);
//WORD_ALIGNED_ATTR char rxbuf[128];


//8 байт 
//____________________________________________________________________________________________________________//
const char* tstr="+Returns ABCD string for esp_err_t and system error codes This function finds the error code in a pre-generated lookup-table of esp_err_t errors and returns its string representation. If the error code is not found then it is attempted to be found among system errors. The function is generated by the Python script tools/gen_esp_err_to_name.py which should be run each time an esp_err_t error is modified, created or removed from the IDF project+";
//____________________________________________________________________________________________________________// 
extern "C" void app_main()
{
  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, 0); //disable brownout detector 
  delay(100);
  initLED(GPIOLED0);
  //GPIO config for the GPIOSW line.
  gpioInit(GPIOSW,GPIO_MODE_INPUT,GPIO_PULLUP_ENABLE,GPIO_PULLDOWN_DISABLE,GPIO_INTR_POSEDGE);
  //Set up GPIOSW line interrupt.
  gpio_install_isr_service(0);
  gpio_set_intr_type((gpio_num_t)GPIOSW, GPIO_INTR_POSEDGE);
  gpio_isr_handler_add((gpio_num_t)GPIOSW, gpio_SW_handler, NULL);

  //=================================
  ledOff(GPIOLED0);
  println("Start SPI...");
  spi_master_config(false);

  //while(1){
    //reset_device();
  //  device_spi_dma_reset();
 //   delay(2000);
 // }

#ifdef TESTSPI_RST
  while(1){
    esp_task_wdt_reset();
    reset_sequence();
    toggleLED();
    delay(5000);
  }
#endif

#ifdef TESTSPI
  SPI_test();
#else
#ifndef TESTING
  WiFi_AP_start();
#endif
#endif

  while(0){
    esp_task_wdt_reset();
    toggleLED();
    delay(1000);
    println("loop led...");
  }
  //=================================
#ifdef TESTING
  
  uint8_t rxbuf[1437];esp_err_t e;
  ICP icp={
    .cmd=0,    //команда 
	  .discrMs=10,//дискретизация,точек в миллисекунду
	  .lx=0,    //младший полубайт X
	  .ly=0,			//младший полубайт Y
	  .hxhy=0x88,   //старшие полубайты XY 2048 2048
	  .r=30,	    //1 байт RED,		0-255
	  .g=20,	    //1 байт GREEN, 0-255
	  .b=10	    //1 байт BLUE,	0-255
  };

  ICP tst[64];
  for(int i=0;i<64;i++){if(i==53)icp.cmd=1;memcpy((void*)&tst[i],&icp,sizeof(ICP));}
  e=0;
  while(1){
    memset(rxbuf,0,129);
    //esp_err_t e=syncTX((uint8_t*)tstr,448,(uint8_t*)rxbuf,64);
    int total=strlen(tstr);int len=0;
    int packet=0;uint8_t* pp=(uint8_t*)tstr;
    for(uint8_t* p=pp;0 && p<pp+448;){
      len=total>64?64:total;
      total-=len;
      e=syncTXRX((uint8_t*)p,len,(uint8_t*)rxbuf,64);
      packet++;
      p+=64;
      //delay(1);
      if(e){//e!=BUSY){
       printf(" * ERROR (tx0): %s ,packet=%d\n",get_errstring(e).c_str(),packet);
      }
      
      //syncTXRX(0,0,(uint8_t*)rxbuf,64);packet++;
      //if(e){//e!=BUSY){
      // printf(" * ERROR (rx0): %s ,packet=%d\n",get_errstring(e).c_str(),packet);
      //}
      //break;
    }
    //e=syncTXRXlong((uint8_t*)tstr,448,0,0);//(uint8_t*)rxbuf,64);
    //e=syncTXRXlong((uint8_t*)tstr,448,(uint8_t*)rxbuf,64);
    uint32_t freesize=9984;
    while(1){
      //uint32_t ran=63*esp_random()/UINT32_MAX;
      
      //printf("random=%d ",(int)esp_random());

      int packetsize=(10+esp_random()%54)*sizeof(ICP);//80
      int injection=esp_random()%(packetsize/sizeof(ICP));//7
      printf("packsize=%d inj=%d/%d , ",packetsize,injection,packetsize/sizeof(ICP));

      for(int i=0;i<64;i++){if(i==injection)icp.cmd=WCMD_FREE;else icp.cmd=0;icp.discrMs=esp_random()%40;memcpy((void*)&tst[i],&icp,sizeof(ICP));}

      if(packetsize>freesize)packetsize=freesize-sizeof(ICP);
      //--------------------
      bzero(rxbuf, sampleLen + 1);
      uint8_t cmd=0;
      for(uint8_t* i=(uint8_t*)tst;i<((uint8_t*)tst)+packetsize;){
        if(*(i)){
          cmd=*(i);//break;
          *(i)=0;
          *(i+1)=0;
          size_t right=((uint8_t*)tst)+packetsize-(i+sizeof(ICP));
          if(right)memmove(i,i+sizeof(ICP),right);
          packetsize-=sizeof(ICP);
        }
        else i+=sizeof(ICP);
      }

      if(cmd)//CMD
      {
        if(packetsize)e=syncTXRXlong((uint8_t*)tst,packetsize,0,0);//1436);
        //rxbuf[packetsize-8]=cmd;
        e=syncTXRXlong((uint8_t*)&cmd,sizeof(cmd),(uint8_t*)rxbuf,64);//1436);
        //printf("SPI cmd=%d rx=%s\n",(int)cmd,rxbuf);
        //delay(2000);
      }
      else e = syncTXRXlong((uint8_t *)tst, packetsize, 0,0,0);// > bytes_received ? bytes_received : txsize);
      //--------------------

      //e=syncTXRXlong((uint8_t*)tst,packetsize,(uint8_t*)rxbuf,64);//1436);


      if(e){//e!=BUSY){
         printf(" * ERROR (rx): %s\n",get_errstring(e).c_str());
       }
       else {
      //   //Serial.print(".");//sync_transaction OK\n");
         //printf("rx=%s ",(char*)rxbuf);
       }

    loop_free:
       if(strlen((char*)rxbuf)){
        rxbuf[strlen((char*)rxbuf)]=0;//term
        char* pp=strstr((char*)rxbuf,"free=");
        if(pp){
          pp+=strlen("free=");
          int n_freesize=atoi(pp);
          freesize=n_freesize;
          printf("n_freesize=%d ",n_freesize);
        }
       }

      printf("\n");
      if(freesize<2*packetsize){
        ICP i1;i1.cmd=WCMD_FREE;
        memset(tst,0,16);
        memcpy(tst,&i1,sizeof(ICP));
        e=syncTXRXlong((uint8_t*)tst,8,(uint8_t*)rxbuf,64);//1436);
        if(e){//e!=BUSY){
           printf(" ERROR (get size): %s\n",get_errstring(e).c_str());
         }
         else {
        //   //Serial.print(".");//sync_transaction OK\n");
           printf("get size=%s \n",(char*)rxbuf);
         }
         goto loop_free;
      }
      //delay(3000);
    }
    
    //if(e){//e!=BUSY){
    //   printf(" * ERROR (rx): %s\n",get_errstring(e).c_str());
    // }
    //if(ite)Serial.println("===> RES ERROR="+String(esp_err_to_name_r(ite,errbuf,64))+"\n");
    //esp_err_t e=syncTX((uint8_t*)tstr,strlen(tstr),(uint8_t*)rxbuf,64);
    //uint32_t v=*((uint32_t*)rxbuf);
    //e=syncTXRX((uint8_t*)&tst[63],8,(uint8_t*)rxbuf,64);packet++;
    //e=syncTXRX(0,0,(uint8_t*)rxbuf,64);packet++;
    
    //toggleLED();
    // delay(1);
    //delay(1000);
  }
#endif
}
//____________________________________________________________________________________________________________//
// GPIOSW interrupt
static void IRAM_ATTR gpio_SW_handler(void* arg)
{
    println("REBOOT");
    esp_restart();
}
//____________________________________________________________________________________________________________//
#ifdef TESTSPI
#define STREAM_DATA_SIZE 10240
static char data[STREAM_DATA_SIZE];

void SPI_test(){

  char bf[65]; bf[64]=0;esp_err_t e=ESP_OK;
  int cntr=0;
  
  ICP icp={
    .cmd=0,    //команда 
	  .discrMs=10,//дискретизация,точек в миллисекунду
	  .lx=0,    //младший полубайт X
	  .ly=0,			//младший полубайт Y
	  .hxhy=0x88,   //старшие полубайты XY 2048 2048
	  .r=30,	    //1 байт RED,		0-255
	  .g=20,	    //1 байт GREEN, 0-255
	  .b=10	    //1 байт BLUE,	0-255
  };

  for(int i=0;i<STREAM_DATA_SIZE;i+=8){memcpy((void*)&data[i],&icp,8);}

  int freesz=0;int spiDeviceReturnFreeSize=0;bool stream=true;
  int stream_block=0;
  int v=0;
  if(stream){
    stream_block=sendCmd(WCMD_STREAM_BLOCKSIZE,0);
    if(stream_block==0xffffffff){printf(" !!! WCMD_STREAM_BLOCKSIZE cmd error\n");while(1){delay(100);};}
    else printf("stream_block=%d\n",stream_block);

    v=sendCmd(WCMD_STREAM);//on
    string ss=(char*)&v;
    if(v==0xffffffff || ss!="ok"){
      printf(" !!! WCMD_STREAM cmd error (ret=%hu)\n",v);
      while(1){delay(100);}
    }
    else{ //OK
      spi_stream_mode=true;
      printf("stream_mode ok\n");
      delay(100);
    }
  }
  
  while (1) {
		cntr++;
    
    int len=STREAM_DATA_SIZE;
    int frsz;uint8_t* pt=(uint8_t*)data;
    int l=len; 
    //каждая транзакция должна начинаться с подготовки DMA
    while(len){ 
      l=len;
      //nowait=true;
      if(stream){
        /*spiDeviceReturnFreeSize=stream_block;
        if(l>stream_block)l=stream_block;
        e=spixfer(pt,l,NULL,portMAX_DELAY);//отправка длины DMA, буфер устанавливает устройство
        if(e){printf(" !!! send_spi_buf DMA STREAM len(%d) error=%s\n",l,string(esp_err_to_name_r(e,bf,64)).c_str());while(1){delay(2000);}}
        */
        e=send_spi_buf((char*)pt,l,spiDeviceReturnFreeSize);
        if(e){printf(" !!! send_spi_buf DMA STREAM len(%d) error=%s\n",l,string(esp_err_to_name_r(e,bf,64)).c_str());while(1){delay(2000);}}
        pt+=l;len-=l;
        printf("[%d] tx=%d\n",cntr,l);
      }
      else{
        if(l>buscfg.max_transfer_sz)l=buscfg.max_transfer_sz;
        uint32_t cmd=WCMD_PREP_DMA;uint32_t arg24bit=l;
        uint32_t c=(arg24bit<<8)|cmd;v=0;
        e=spitx((uint8_t*)&c,4,&v);
        if(e){printf("sendCmd error=%s\n",string(esp_err_to_name_r(e,bf,64)).c_str());while(1){delay(2000);}}
        else printf("sendCmd(%hu) RESULT=%hu\n",cmd,v);
        uint v2=(uint)v;
        frsz=((v2>>16)&0xffff);v=(v2&0xffff);
        if(v<=0){
          printf("prepareDeviceDMA error: length(%d)<=0, length(%d)\n",v,freesz);
          delay(2000);
          continue;
        }
        
        printf("prepareDeviceDMA : length=%d, return free=%d\n",(int)v,frsz);
        l=v;
        if(l%8){
          printf("prepareDeviceDMA : ERROR ALIGN =%d\n",(int)(l%8));
          while(1){delay(100);}
        }
        //==========================================================
        if(!l){
          printf("- send_spi_buf incorrect DMA length: tx len=%d, error=%s, continue...\n",l,string(esp_err_to_name_r(e,bf,64)).c_str());
          continue;
        }
        e=spitx(pt,l,&v);
        if(e){
          printf("- STREAM :: send_spi_buf DMA len(%d) error=%s\n",l,string(esp_err_to_name_r(e,bf,64)).c_str());
          spiDeviceReturnFreeSize=0;
          while(1){delay(100);} //return e;
        }

        printf("STREAM : return %d\n",(int)v);

        int loaded=v&0xffff;
        spiDeviceReturnFreeSize=frsz=(v>>16);
        printf("- send_spi_buf return free=%d, loaded=%d\n",frsz,loaded); //21059 == CRC ERR
      
      }
    }
    //----------------
    //delay(1000);
  }
}
#endif //TESTSPI



